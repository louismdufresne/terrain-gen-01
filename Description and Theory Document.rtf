{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Cambria;}{\f1\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qj\f0\fs28\lang9 MESH-SOURCED VOXEL-BASED TERRAIN GENERATION PROJECT\line DESCRIPTION AND THEORY DOCUMENT\line\line Developer:\tab Louis Dufresne\line Version:\tab v0.0.1\line\line DESCRIPTION\line\line This project is a Unity-built game-like simulation which currently generates block-based terrain using 'chunks' based on data from an input mesh.\line\line Mesh data from a given object (here specified by an .OBJ file of a mountain created in Blender, shown rotating in the upper right corner) is sourced, modified, and internally stored as custom manipulable objects. These objects comprise a 'scape' composed of 'smart triangles', themselves composed of 'smart vertices', which store the modified mesh data. Scapes are generated and then placed at specified locations in the world. In this project's current state, the mountain is placed in the middle of the world.\line\line During world building, chunks are generated by sourcing elevation data from scapes. For each block in a chunk, the game first determines which scapes are present at that block; multiple scapes can stack on top of each other. For each scape, the topmost triangle located at the coordinates of that block is selected. A value of elevation is derived from interpolating the selected triangle at the location of the block. All elevations derived from all scapes at a given block are summed to yield the final elevation. Blocks located above this elevation are generated as air; blocks located directly on the elevation are grass; blocks just below the elevation are dirt; and blocks further below, down to the world floor, are generated as stone. \line\line Chunks are then drawn by building voxel-based meshes to represent the block types present throughout the chunk. Only faces visible to the 'air' are drawn. The world is both generated and drawn in chunks, and chunk-loading follows a pattern around the location of the player which prioritizes generating the closest chunks first.\line\line Lastly, the project implements a free-flying camera which can be operated to navigate the world and view the terrain from multiple angles.\line\line THEORY\line\line The original purpose for developing this project was to explore additional avenues for world generation which did not rely on sourcing elevational data primarily from noise maps. The main example of a project wherein terrain is sourced primarily from noise maps is Minecraft, with which I have several gripes. Notably, terrain in Minecraft is restricted in ways which seem almost arbitrary, and these restrictions prevent the development of more realistic terrain; I've always found Minecraft's terrain to be overly simplistic, undiverse, and to an extent, uninteresting. Limitations include such examples as rivers being permanently stuck at sea level, terrain appearing unnaturally smoothed, terrain generating in blatantly unnatural ways (such as ravines lying adjacent to oceans), and the terrains of various biomes developing a sense of 'saminess'. However, as I have a profound nostalgia and love for the game, I thought to channel my energy into seeking avenues for improvement, and testing the viability of each.\line\line This project adapts older research into Minecraft-like terrain and mesh generation, using experience I had gained from researching and then implementing procedural 3D mesh generation and related theory. I therefore also adapted for this project a rudimentary block-typing system, whereby blocks of certain types can be generated, stored, and drawn. Additionally, block texture UVs are pseudorandomly rotated and otherwise manipulated to achieve an added sense of textural depth and to break up patterns which arise from repeated use of the same texture.\line\line The idea to store terrain data in 'scapes' which are then added to build elevations came from my dissatisfaction at existing terrain generation resources and tutorials present on sites such as YouTube, which again focus mainly on noise maps. I wanted to devise a system where terrain could be procedurally generated by first placing rough terrain elements which could then be procedurally refined and articulated. I recognized that, since many terrain features such as rivers and ridges manifest as 'lines' (or specifically collections of connected line segments), then a system which generates locations of non-intersecting 'ridge' lines and 'trough' lines (which may be refined into mountains and rivers, respectively) with offshoots to specify additional terrain detail could theoretically generate much more realistic terrain, where troughs could be manipulated to only flow downhill and into seas, ridge lines could rise to peaks, et cetera. Detailed terrain could then be built given the interplay between ridges and troughs. However, such generation of lines alone would not constitute terrain, and this project aimed to establish a groundwork for the types of data objects capable of manipulating and storing the resultant terrain, namely in the form of triangles. The scape aims to bridge the gap between triangle formation and block generation.\line\line However, as shown in this project, scapes have the added benefit of being directly writeable using existing mesh data, which is also stored primarily as triangles. Here, the scape is simply built by scaling the triangles and vertices present in the mesh to a desired size and location. This also opens the future possibility to incorporate pre-defined assets in generation, and could theoretically facilitate the generation of unique terrain by stacking existing assets together.\line\line This project utilizes an architectural methodology which I have since refined, but I have not applied the refinements to this project. Early on I aimed to establish a separation between 'data' and 'visuals' in my work, where the visuals exist entirely to represent the data rather than the data and visuals co-existing. Unity is not an ideal platform to develop with this methodology, as the primary object unit of the platform, the 'GameObject', directly combines the two (and encourages this combination). I find that combining visuals and data leads to a sort of decentralization of internal communication, which does not improve the performance of the product and only serves to complicate inter-object communication; while Unity's preferred method is ideal perhaps for extremely simple applications, it is almost entirely unscalable. In subsequent projects, I have built my own custom input and game framework (which I use across various projects) which aims in part to facilitate the generation of mesh-based visuals using a generic, poolable object called a MeshVisual which can be drawn and redrawn to meet differing visual needs. Here however, within this project, I represent the visual aspect of chunks using an object called a 'MeshDraw', which is a sort of precursor to the MeshVisual and which does not utilize the input management framework I later devised. This project does still take steps to separate out the data component, storing chunk data as a separate entity to the visual data; however, in practice, the two are not meaningfully separated.\line\line Additionally, this project utilizes an archaic version of an arcitectural principle I use whereby various systems are modularized completely, and communication between modules is minimized to both simplify the program's internal operations and to facilitate the rigorous testing and bugfixing of each module and related submodules. In this project, modules are not clearly defined, and the operations of various systems are distributed in a way which was initially unclear to me when I went back into this project to clean it up a few days ago. I found myself unhappy with the internal division of work, as well as with the exact methodologies employed to generate and draw terrain. While I am already devising ways to improve or entirely rebuild the project to better adhere to my own newer principles, I have elected to leave the project as-is for the most part for two main reasons. One, it currently works; and two, I could not reasonably complete and then test all of the changes I wanted to make within an appropriate timeframe. As I needed to have the project in a viewable state in only a few days, I only made a few major changes, such as finalizing the mesh-to-scape pipeline and implementing some bugfixes.\line\line Ultimately, however, I am proud of this project. I believe it succeeded in demonstrating a number of elements of my theorized terrain generation, and I am keenly interested in continuing to pursue further development of these generation principles in the future.\line\line\line\f1\fs22\par
}
 